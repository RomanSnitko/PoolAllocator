# PoolAllocator

Пуловый аллокатор памяти на C++, реализующий упрощённый аналог malloc/free на основе пулов фиксированного размера.  
Аллокатор ориентирован на предсказуемое время работы (O(1)) и минимальную фрагментацию памяти.

Проект является учебной, но архитектурно корректной реализацией аллокатора, близкой по идеям к промышленным системам управления памятью.

---

## В чем идея

Обычный `malloc/free`:

- универсален, но сложен;
- часто имеет непредсказуемое время работы;
- страдает от фрагментации;
- использует скрытые метаданные рядом с каждым блоком.

Если заранее известно, что:
- память выделяется блоками ограниченных размеров;
- важны скорость и предсказуемость,

то выгодно использовать **пуловый аллокатор**.

---

## Архитектура

Реализация состоит из **двух уровней**:

1. **Pool** — базовый строительный блок
2. **PoolAllocator** — менеджер множества пулов (аналог `malloc/free`)

---

## Pool (фиксированный размер)

`Pool` управляет одним непрерывным куском памяти и:

- разбивает его на чанки одинакового размера;
- умеет:
  - `acquire()` — выдать свободный чанк;
  - `release(ptr)` — вернуть чанк обратно.

### Ключевая идея

Пул использует **два источника свободной памяти**:

1. **Grow-only область**  
   Чанки, которые ещё ни разу не выдавались, вычисляются арифметически:

addr = base + index * chunk_size


2. **Список освобождённых чанков**  
Освобождённые чанки складываются в односвязный список, где указатель `next`
хранится прямо в памяти чанка.

Таким образом:

- инициализация пула — O(1);
- `acquire()` — O(1);
- `release()` — O(1);
- не требуется предварительно строить список всех чанков.

---

## PoolAllocator (упрощённый malloc/free)

`PoolAllocator` объединяет множество `Pool` и работает поверх **одного глобального блока памяти**.

### Shards

Глобальная память разбивается на равные части — **shards**.

- один shard = один пул;
- размер shard фиксирован;
- индекс shard используется как идентификатор пула.

---

### Control Blocks

Для каждого shard существует **контрольный блок**, содержащий:

- объект `Pool`;
- размер чанка;
- служебные поля для связывания в списки.

Индекс контрольного блока **равен индексу shard**, что позволяет находить пул по адресу.

---

### Bins (корзины размеров)

Чтобы поддерживать разные размеры запросов:

- все размеры чанков — степени двойки;
- запрос округляется вверх до ближайшего подходящего размера;
- для каждого размера существует **bin** — список пулов, выдающих чанки этого размера.

Номер bin вычисляется арифметически через `std::bit_width`, без таблиц и ветвлений.

---

## Как работает allocate

1. Пользователь запрашивает `size` байт.
2. Размер округляется до ближайшей степени двойки.
3. По размеру определяется bin.
4. Аллокатор:
- пытается выделить память из существующих пулов bin;
- если пулов нет — создаёт новый пул на свободном shard.
5. Возвращается указатель на чанк.

---

## Как работает free

Для `free(ptr)`:

1. По адресу `ptr` вычисляется смещение от начала глобальной памяти.
2. Делением на `shard_size` находится индекс shard.
3. По этому индексу находится нужный пул.
4. Указатель возвращается в соответствующий `Pool`.

**Метаданные рядом с блоком не используются** — пул находится скажем так *по адресу*.

---

## Визуализация

Глобальная память:
[ Shard 0 ][ Shard 1 ][ Shard 2 ][ Shard 3 ] ...

Control blocks:
[ Pool 0 ][ Pool 1 ][ Pool 2 ][ Pool 3 ] ...

Bins:
32B -> Pool 0 -> Pool 3
64B -> Pool 1
128B -> Pool 2


---

## Свойства реализации

- O(1) allocate / free
- Фиксированные size-classes
- Минимальная фрагментация
- Предсказуемое поведение
- Без скрытых метаданных рядом с пользовательской памятью
- Однопоточная модель (по заданию)

---

## Используемые возможности C++

- `std::span` — безопасная передача диапазонов памяти
- `std::bit_ceil`, `std::bit_width` — быстрые операции над степенями двойки
- RAII — управление ресурсами без утечек
- Современный стиль C++20

---
